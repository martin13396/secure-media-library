# Video Streaming Project - Complete Specifications v1.0

## Project Overview

The Video Streaming Project is a secure, private media management and streaming platform designed for home network use, accessible exclusively through a router-based OpenVPN connection. This Docker-containerized system runs on Mac Mini and provides authenticated users with access to encrypted photo and video content within a controlled network environment. Built with Python and Next.js, the system implements military-grade AES-128 encryption for all media assets, secure HLS video streaming with encrypted segments, and comprehensive user session management with advanced security features.

### Network Architecture

The platform operates in a containerized environment on Mac Mini with controlled access:
- **Host Platform**: Mac Mini (Apple Silicon/Intel)
- **Host IP**: localhost (configurable via PUBLIC_BASE_URL)
- **Application Port**: 1027
- **Access Method**: Router-based OpenVPN connection required
- **VPN Configuration** (Router-level):
  - Service Port: 1194
  - Service Type: UDP
  - VPN Subnet: 10.8.0.0
  - Netmask: 255.255.255.0
  - Client Access: Home Network Only
- **No Public Internet Access**: System is completely isolated from public networks

### Core Functionality

The platform processes media files through a sophisticated pipeline that ensures security at every step:

1. **Media Ingestion** - Admin uploads raw media files to a designated import directory
2. **Automated Processing** - Python script automatically detects and processes new media files
3. **Image Optimization** - Converts all images to WebP format with AES-128 encryption
4. **Video Transcoding** - Converts videos to HLS format with encrypted segments
5. **Animated Thumbnail Generation** - Creates WebP animations as video previews
6. **Secure Storage** - Stores processed media in protected directories inaccessible via direct URL
7. **Authentication System** - Multi-device session management with automatic logout
8. **Secure Delivery** - Encrypted content delivery through authenticated API endpoints
9. **Media Gallery** - Responsive frontend for browsing and viewing encrypted media with animated previews

### Deployment Architecture

The entire system runs in Docker containers on a single Mac Mini host (localhost) with the following characteristics:
- **Port**: 1027 (HTTPS only)
- **Access Methods**: 
  - Remote: Via router-based OpenVPN (10.8.0.x subnet)
  - Local: Direct access on same network (192.168.1.x)
- **Container Stack**: Nginx, Next.js, Python processor, PostgreSQL, Redis
- **Data Persistence**: Docker volumes for database, bind mounts for media files
- **Media Preview**: Animated WebP thumbnails provide instant video previews without loading full content

### Key Features

- **VPN-Only Access**: Complete network isolation with mandatory OpenVPN authentication
- **Zero External Exposure**: No public internet access reduces attack surface to zero
- **Military-Grade HLS Encryption**: All video segments encrypted using AES-128-CBC with unique IVs
- **Animated WebP Thumbnails**: Auto-generated animated previews for enhanced user experience
- **Multi-Device Session Control**: Users can manage sessions across devices with forced logout capability
- **Auto-Logout Security**: Automatic session termination after 30 minutes of inactivity
- **Zero-Trust Architecture**: No direct URL access to media files; all access through authenticated APIs
- **Automated Processing**: Watch folder system for automatic media ingestion and processing
- **Adaptive Streaming**: HLS streaming with automatic quality adjustment based on bandwidth
- **Self-Signed SSL**: HTTPS support with self-signed certificates for VPN subnet
- **Mac Mini Optimized**: Docker configuration optimized for Apple Silicon and Intel Macs
- **Comprehensive Logging**: Detailed audit trails for all access and processing activities

### Technical Architecture

The system consists of three main components:

1. **Processing Engine (Python)**
   - File watcher for automatic media detection
   - FFmpeg integration for video transcoding
   - Image processing with encryption
   - Key management system
   
2. **API Backend (Next.js)**
   - RESTful API for authentication and media access
   - Session management with Redis
   - Encrypted content delivery endpoints
   - WebSocket support for real-time updates
   
3. **Frontend Application (Next.js)**
   - Responsive media gallery interface
   - Secure media player with HLS.js integration
   - Session management UI
   - Real-time activity monitoring

### Security Architecture

- **Network Isolation**: System only accessible through OpenVPN connection
- **VPN Authentication**: Additional authentication layer before system access
- **Encryption at Rest**: All media files encrypted with AES-128
- **Encryption in Transit**: HTTPS with self-signed SSL certificates (valid for VPN subnet)
- **HLS Encryption**: Each video segment encrypted with AES-128-CBC
- **Access Control**: Token-based authentication with refresh tokens
- **Session Security**: Redis-backed sessions with device fingerprinting
- **Key Rotation**: Automatic encryption key rotation every 30 days
- **Audit Logging**: Comprehensive logging of all access attempts from VPN clients

### HLS Encryption Security

1. **Segment-Level Encryption**
   - Each 10-second .ts segment is individually encrypted
   - Even if someone obtains a segment file, it's unplayable without the key
   - Key URL requires authentication to access

2. **Key Protection**
   - Encryption keys never leave the server unencrypted
   - Keys are served only to authenticated users
   - Each key request is logged for audit purposes
   - Keys are rotated monthly to limit exposure

3. **IV (Initialization Vector) Security**
   - Each video has a unique IV
   - Prevents identical content from producing identical ciphertext
   - Stored securely in the database per video

4. **Playback Security**
   - Players must authenticate to fetch encryption keys
   - Keys are not cached by default
   - Session validation on each key request

### Security Benefits of VPN-Only Architecture

1. **Complete Network Isolation**
   - No exposure to public internet
   - Immune to external port scanning
   - Protected from DDoS attacks
   - No risk of accidental public exposure

2. **Multi-Layer Authentication**
   - VPN certificate authentication
   - Application-level user authentication
   - Device fingerprinting for sessions
   - IP-based access restrictions

3. **Simplified Security Model**
   - No need for complex firewall rules
   - Reduced attack surface
   - Easier security auditing
   - Clear access boundaries

### Animated Thumbnail Benefits

1. **Enhanced User Experience**
   - Instant preview without loading video
   - Quick content identification
   - Reduced bandwidth for browsing
   - Smooth hover interactions

2. **Intelligent Preview Generation**
   - Scene-based selection shows key moments
   - Skips intro/credits automatically
   - Consistent quality across all videos
   - Optimized file sizes with WebP

3. **Security Integration**
   - Thumbnails encrypted like all media
   - Access control for preview content
   - No direct file access
   - Audit trail for thumbnail views

### Output Deliverables

Each processed media file produces:
- **Images**: WebP format with AES-128 encryption
- **Videos**: HLS playlist with encrypted segments
- **Metadata**: JSON files with processing details
- **Encryption Keys**: Secure key storage with rotation history

## Project Requirements

**Backend Language**: Python 3.12+
**Frontend Framework**: Next.js 15+
**Database**: PostgreSQL 15+
**Cache/Session Store**: Redis 7+
**Media Processing**: FFmpeg 6+
**Encryption**: OpenSSL 3+
**Container Platform**: Docker 24+ & Docker Compose 2.20+

## System Architecture Components

### Docker Container Architecture
```
Docker Host (127.0.0.1:1027)
│
├── nginx (Reverse Proxy & SSL Termination)
│   └── Port 1027 (HTTPS)
│
├── nextjs-app (Frontend & API)
│   └── Port 3000 (Internal)
│
├── media-processor (Python Service)
│   ├── File Watcher
│   ├── FFmpeg Processing
│   └── Encryption Service
│
├── postgres (Database)
│   └── Port 5432 (Internal)
│
└── redis (Session Store)
    └── Port 6379 (Internal)
```

### 1. File Processing Service (Python Container)
- Monitors `@imports` directory for new files
- Processes images to WebP with encryption
- Transcodes videos to HLS format
- Manages encryption keys
- Updates database with processed file metadata

### 2. API Service (Next.js API Routes)
- `/api/auth/*` - Authentication endpoints
- `/api/media/*` - Media access endpoints
- `/api/sessions/*` - Session management
- `/api/admin/*` - Administrative functions

### 3. Frontend Application (Next.js)
- Photo/Video gallery with grid layout
- Media player with encrypted HLS support
- User profile and session management
- Admin dashboard for monitoring

### 4. Security Services
- Token generation and validation
- Session management with Redis
- Encryption/decryption services
- SSL certificate management

## System Flow

### User Authentication Flow
1. **Login Request**: User submits credentials through secure form
2. **Credential Validation**: System validates against hashed passwords in database
3. **Device Fingerprinting**: Captures device information for session tracking
4. **Token Generation**: Creates JWT access token and refresh token
5. **Session Creation**: Stores session in Redis with device information
6. **Response**: Returns tokens and user profile to client

### Media Processing Flow
1. **File Detection**: Python watcher detects new files in `@imports`
2. **File Validation**: Checks file type and integrity
3. **Processing Queue**: Adds file to processing queue in database
4. **Image Processing**: 
   - Converts to WebP format
   - Applies AES-128 encryption
   - Stores in `@assets/images`
5. **Video Processing**:
   - Extracts video metadata (duration, dimensions)
   - Generates animated thumbnails:
     - Standard: 3-second loop from 10% point
     - Preview: Scene-based animation (up to 20 frames)
   - Encrypts thumbnails with AES-128
   - Transcodes to HLS using FFmpeg
   - Segments video into 10-second chunks
   - Encrypts each segment with unique IV
   - Generates playlist file
   - Stores in `@assets/videos/{video_id}/`
6. **Metadata Storage**: Updates database with file information and paths
7. **Cleanup**: Removes original file from `@imports`

### Media Access Flow
1. **Request**: Client requests media through API endpoint
2. **Authentication**: Validates JWT token
3. **Authorization**: Checks user permissions
4. **Key Retrieval**: Gets encryption key for requested media
5. **Stream Generation**: Creates secure stream URL with temporary token
6. **Delivery**: Serves encrypted content through API
7. **Logging**: Records access in audit log

## Database Design

### users
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100) NOT NULL,
    role ENUM('admin', 'user') DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    last_login_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_active ON users(is_active);
```

### sessions
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    device_id VARCHAR(255) NOT NULL,
    device_name VARCHAR(100),
    device_type VARCHAR(50),
    ip_address INET NOT NULL,
    user_agent TEXT,
    refresh_token_hash VARCHAR(255) UNIQUE NOT NULL,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT unique_user_device UNIQUE(user_id, device_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_sessions_user ON sessions(user_id);
CREATE INDEX idx_sessions_token ON sessions(refresh_token_hash);
CREATE INDEX idx_sessions_expiry ON sessions(expires_at);
CREATE INDEX idx_sessions_activity ON sessions(last_activity_at);
```

### media_files
```sql
CREATE TABLE media_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    original_name VARCHAR(255) NOT NULL,
    file_type ENUM('image', 'video') NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size_bytes BIGINT NOT NULL,
    width INT,
    height INT,
    duration_seconds DECIMAL(10,2),
    storage_path VARCHAR(500) NOT NULL,
    thumbnail_path VARCHAR(500),
    preview_path VARCHAR(500),  -- Animated WebP preview
    encryption_key_id UUID NOT NULL,
    processing_status ENUM('pending', 'processing', 'completed', 'failed') DEFAULT 'pending',
    processing_started_at TIMESTAMP,
    processing_completed_at TIMESTAMP,
    error_message TEXT,
    metadata JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (encryption_key_id) REFERENCES encryption_keys(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_media_type ON media_files(file_type);
CREATE INDEX idx_media_status ON media_files(processing_status);
CREATE INDEX idx_media_created ON media_files(created_at);
```

### encryption_keys
```sql
CREATE TABLE encryption_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    key_value VARCHAR(512) NOT NULL, -- Encrypted with master key
    iv_value VARCHAR(256) NOT NULL,
    algorithm VARCHAR(50) DEFAULT 'AES-128-CBC',
    is_active BOOLEAN DEFAULT true,
    rotation_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expired_at TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_keys_active ON encryption_keys(is_active);
CREATE INDEX idx_keys_rotation ON encryption_keys(rotation_date);
```

### access_logs
```sql
CREATE TABLE access_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL,
    session_id UUID NOT NULL,
    media_file_id UUID NOT NULL,
    action VARCHAR(50) NOT NULL, -- 'view', 'download', 'stream'
    ip_address INET NOT NULL,
    vpn_client_ip INET NOT NULL, -- VPN assigned IP (10.8.0.x)
    user_agent TEXT,
    response_time_ms INT,
    bytes_transferred BIGINT,
    status_code INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (session_id) REFERENCES sessions(id),
    FOREIGN KEY (media_file_id) REFERENCES media_files(id),
    CONSTRAINT chk_vpn_subnet CHECK (vpn_client_ip << inet '10.8.0.0/24')
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_logs_user ON access_logs(user_id);
CREATE INDEX idx_logs_media ON access_logs(media_file_id);
CREATE INDEX idx_logs_created ON access_logs(created_at);
CREATE INDEX idx_logs_session ON access_logs(session_id);
CREATE INDEX idx_logs_vpn_ip ON access_logs(vpn_client_ip);
```

### processing_queue
```sql
CREATE TABLE processing_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_path VARCHAR(500) NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    priority INT DEFAULT 5,
    status ENUM('queued', 'processing', 'completed', 'failed') DEFAULT 'queued',
    retry_count INT DEFAULT 0,
    max_retries INT DEFAULT 3,
    error_message TEXT,
    worker_id VARCHAR(100),
    queued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    CONSTRAINT unique_file_path UNIQUE(file_path)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE INDEX idx_queue_status ON processing_queue(status, priority);
CREATE INDEX idx_queue_worker ON processing_queue(worker_id);
```

## Configuration

### config.yaml
```yaml
# Application Configuration
app:
  name: "Secure Media Streaming Platform"
  version: "1.0.0"
  environment: ${APP_ENV:development}
  debug: ${DEBUG:false}
  
# Server Configuration
server:
  host: ${SERVER_HOST:0.0.0.0}  # Bind to all interfaces in container
  port: ${SERVER_PORT:1027}
  ssl:
    enabled: ${SSL_ENABLED:true}
    cert_path: ${SSL_CERT_PATH:/app/private/server.pem}
    key_path: ${SSL_KEY_PATH:/app/private/server.pem}
  cors:
    allowed_origins: 
      - "https://localhost:1027"
      - "https://127.0.0.1:1027"
    allowed_methods: ["GET", "POST", "PUT", "DELETE"]
    allowed_headers: ["Authorization", "Content-Type"]
  # Network restrictions
  allowed_ips:
    - "127.0.0.1"
    - "::1"
    - "172.16.0.0/12"  # Docker internal network
    - "192.168.1.0/24"  # Local network
    - "10.8.0.0/24"  # VPN subnet only

# Database Configuration  
database:
  postgres:
    host: ${DB_HOST:localhost}
    port: ${DB_PORT:5432}
    database: ${DB_NAME:media_streaming}
    username: ${DB_USER:postgres}
    password: ${DB_PASSWORD:password}
    ssl_mode: ${DB_SSL_MODE:require}
    pool:
      min_connections: 5
      max_connections: 20
      connection_timeout: 30s

# Redis Configuration
redis:
  host: ${REDIS_HOST:localhost}
  port: ${REDIS_PORT:6379}
  password: ${REDIS_PASSWORD:}
  database: ${REDIS_DB:0}
  ssl: ${REDIS_SSL:false}
  session_ttl: 1800 # 30 minutes in seconds

# Storage Configuration
storage:
  base_path: ${STORAGE_BASE_PATH:./}
  directories:
    imports: "${storage.base_path}/@imports"
    assets: "${storage.base_path}/@assets"
    images: "${storage.base_path}/@assets/images"
    videos: "${storage.base_path}/@assets/videos"
    private: "${storage.base_path}/private"
    temp: "${storage.base_path}/temp"

# Media Processing Configuration
media:
  processing:
    watch_interval: 5 # seconds
    concurrent_workers: ${WORKERS:4}
    
  image:
    output_format: "webp"
    quality: 85
    max_width: 3840
    max_height: 2160
    thumbnail:
      width: 300
      height: 300
      
  video:
    output_format: "hls"
    segment_duration: 10 # seconds
    preset: "veryfast"
    crf: 23
    audio_bitrate: "128k"
    resolutions:
      - { name: "720p", height: 720, bitrate: "3000k" }
      - { name: "480p", height: 480, bitrate: "1500k" }
      - { name: "360p", height: 360, bitrate: "800k" }
    
  thumbnail:
    format: "webp"
    animated: true
    standard:  # 3-second preview from interesting part
      width: 320
      fps: 10
      duration: 3  # seconds
      quality: 75
      compression_level: 6
      start_position: "10%"  # Start at 10% of video duration
    preview:  # Scene-based preview
      width: 480
      fps: 5
      max_frames: 20
      quality: 80
      compression_level: 6
      scene_threshold: 0.4  # Scene change detection threshold

# Security Configuration
security:
  jwt:
    access_token_secret: ${JWT_ACCESS_SECRET}
    refresh_token_secret: ${JWT_REFRESH_SECRET}
    access_token_expiry: "15m"
    refresh_token_expiry: "7d"
    
  encryption:
    algorithm: "AES-128-CBC"
    master_key: ${MASTER_ENCRYPTION_KEY}
    key_rotation_days: 30
    
  session:
    timeout_minutes: 30
    max_devices_per_user: 5
    
  password:
    min_length: 8
    require_uppercase: true
    require_lowercase: true
    require_numbers: true
    require_special: true
    bcrypt_rounds: 12

# FFmpeg Configuration
ffmpeg:
  binary_path: ${FFMPEG_PATH:ffmpeg}
  threads: ${FFMPEG_THREADS:0} # 0 = auto
  hwaccel: ${FFMPEG_HWACCEL:none} # none, cuda, vaapi, qsv
  
# Logging Configuration
logging:
  level: ${LOG_LEVEL:info}
  format: "json"
  outputs:
    - type: "console"
      level: ${LOG_LEVEL:info}
    - type: "file"
      path: "./logs/app.log"
      max_size_mb: 100
      max_backups: 5
      max_age_days: 30
```

### key_info.txt (HLS Encryption)
```
https://localhost:1027/api/media/keys/{key_id}
/app/private/encryption.key
{random_iv_hex}
```

## API Specifications

### Security Middleware

All API endpoints enforce the following security checks:

1. **VPN Subnet Validation**
```javascript
// Middleware to ensure requests come from VPN subnet
const vpnSubnetCheck = (req, res, next) => {
  const clientIP = req.ip || req.connection.remoteAddress;
  
  // Check if IP is in allowed ranges
  const allowedRanges = ['127.0.0.1', '::1', '10.8.0.0/24'];
  
  if (!isIPInAllowedRanges(clientIP, allowedRanges)) {
    return res.status(403).json({
      error: {
        code: "SEC_001",
        message: "Access denied: VPN connection required"
      }
    });
  }
  
  next();
};
```

2. **Authentication Check**
```javascript
// JWT validation middleware
const authCheck = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({
      error: {
        code: "AUTH_001",
        message: "Authentication required"
      }
    });
  }
  
  // Validate JWT token
  // Check session in Redis
  // Verify device fingerprint
  
  next();
};
```

### Authentication Endpoints

#### POST /api/auth/login
```json
// Request
{
  "username": "user@example.com",
  "password": "SecurePassword123!",
  "device_name": "Chrome on MacBook"
}

// Response
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
  "expires_in": 900,
  "user": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "username": "johndoe",
    "email": "user@example.com",
    "role": "user"
  }
}
```

#### POST /api/auth/logout
```json
// Request
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIs...",
  "logout_all_devices": false
}

// Response
{
  "message": "Logged out successfully",
  "devices_affected": 1
}
```

#### POST /api/auth/refresh
```json
// Request
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIs..."
}

// Response
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "expires_in": 900
}
```

### Media Access Endpoints

#### GET /api/media/library
```json
// Query Parameters
// ?type=all|image|video
// ?page=1&limit=20
// ?sort=created_at|name
// ?order=asc|desc

// Response
{
  "data": [
    {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "name": "vacation_video.mp4",
      "type": "video",
      "thumbnail_url": "/api/media/thumbnail/123e4567",
      "preview_url": "/api/media/preview/123e4567",  // Animated WebP
      "created_at": "2024-01-15T10:30:00Z",
      "metadata": {
        "width": 1920,
        "height": 1080,
        "duration": 120.5,
        "size_bytes": 104857600
      }
    },
    {
      "id": "234e5678-e89b-12d3-a456-426614174001",
      "name": "sunset_photo.jpg",
      "type": "image",
      "thumbnail_url": "/api/media/thumbnail/234e5678",
      "preview_url": null,  // No preview for images
      "created_at": "2024-01-15T11:00:00Z",
      "metadata": {
        "width": 3840,
        "height": 2160,
        "size_bytes": 2048576
      }
    }
  ],
  "pagination": {
    "total": 150,
    "page": 1,
    "limit": 20,
    "pages": 8
  }
}
```

#### GET /api/media/thumbnail/{media_id}
```typescript
// Serves decrypted animated WebP thumbnails
// Only accessible with valid authentication

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { media_id } = req.query;
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!verifyToken(token)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // Get thumbnail path from database
  const media = await getMediaById(media_id);
  if (!media || !media.thumbnail_path) {
    return res.status(404).json({ error: 'Thumbnail not found' });
  }
  
  // Read encrypted thumbnail
  const encryptedPath = `/app/assets/${media.thumbnail_path}`;
  const encryptedData = await fs.readFile(encryptedPath);
  
  // Extract IV (first 16 bytes) and ciphertext
  const iv = encryptedData.slice(0, 16);
  const ciphertext = encryptedData.slice(16);
  
  // Decrypt thumbnail
  const key = await fs.readFile('/app/private/encryption.key', 'utf8');
  const keyBuffer = Buffer.from(key.trim(), 'hex');
  
  const decipher = crypto.createDecipheriv('aes-128-cbc', keyBuffer, iv);
  let decrypted = Buffer.concat([
    decipher.update(ciphertext),
    decipher.final()
  ]);
  
  // Remove padding
  const padLength = decrypted[decrypted.length - 1];
  decrypted = decrypted.slice(0, -padLength);
  
  // Return decrypted WebP
  res.setHeader('Content-Type', 'image/webp');
  res.setHeader('Cache-Control', 'private, max-age=3600');
  res.send(decrypted);
}
```

#### GET /api/media/preview/{media_id}
```typescript
// Serves larger animated WebP previews (scene-based)
// Similar implementation to thumbnail endpoint but serves preview_path
```

#### GET /api/media/keys/{key_id}
```json
// This endpoint serves encryption keys for HLS playback
// Only accessible with valid authentication

// Headers
// Authorization: Bearer {access_token}

// Response
// Content-Type: application/octet-stream
// Content-Length: 16
// Cache-Control: no-cache, no-store, must-revalidate
// [16 bytes of binary key data]

// Implementation (Next.js API Route)
// pages/api/media/keys/[key_id].ts
```

```typescript
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Verify authentication
  const token = req.headers.authorization?.split(' ')[1];
  if (!verifyToken(token)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // Get key_id from query
  const { key_id } = req.query;
  
  // Verify user has access to this video
  const hasAccess = await checkVideoAccess(token, key_id);
  if (!hasAccess) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  // Read encryption key
  const keyPath = '/app/private/encryption.key';
  const key = await fs.readFile(keyPath);
  
  // Log access
  await logKeyAccess(token, key_id);
  
  // Return binary key data
  res.setHeader('Content-Type', 'application/octet-stream');
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.send(Buffer.from(key, 'hex'));
}
```

#### GET /api/media/stream/{media_id}
```json
// Headers
// Authorization: Bearer {access_token}

// Response for Images
// Content-Type: image/webp
// X-Encrypted: true
// [Binary encrypted image data]

// Response for Videos (Encrypted HLS Playlist)
// Content-Type: application/vnd.apple.mpegurl
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-KEY:METHOD=AES-128,URI="https://localhost:1027/api/media/keys/abc123",IV=0x12345678901234567890123456789012
#EXTINF:10.0,
https://localhost:1027/api/media/segment/video_id/segment000.ts
#EXTINF:10.0,
https://localhost:1027/api/media/segment/video_id/segment001.ts
#EXT-X-ENDLIST

// Note: Each .ts segment is encrypted with AES-128
// The player must fetch the key from the URI to decrypt segments
```

### Session Management Endpoints

#### GET /api/sessions
```json
// Response
{
  "sessions": [
    {
      "id": "session_123",
      "device_name": "Chrome on MacBook",
      "device_type": "desktop",
      "ip_address": "192.168.1.100",
      "last_activity": "2024-01-15T10:30:00Z",
      "is_current": true
    }
  ]
}
```

#### DELETE /api/sessions/{session_id}
```json
// Response
{
  "message": "Session terminated successfully"
}
```

### Processing Script with HLS Encryption and Animated Thumbnails

#### process_files.py (excerpt)
```python
#!/usr/bin/env python3
"""
Media Processing Script with HLS Encryption and Animated Thumbnails
Monitors import directory and processes media files
"""

import os
import subprocess
import secrets
from pathlib import Path
from typing import Tuple
import asyncio

class VideoProcessor:
    def __init__(self):
        self.encryption_key_path = Path("/app/private/encryption.key")
        self.imports_dir = Path("/app/imports")
        self.assets_dir = Path("/app/assets")
        
    def generate_iv(self):
        """Generate a random IV for HLS encryption"""
        return secrets.token_hex(16)
    
    def create_key_info_file(self, video_id, iv):
        """Create key_info.txt for FFmpeg HLS encryption"""
        key_info_path = Path(f"/app/private/key_info_{video_id}.txt")
        
        with open(key_info_path, 'w') as f:
            # URL where the player will fetch the key
            f.write(f"{os.getenv('PUBLIC_BASE_URL', 'https://localhost:1027')}/api/media/keys/{video_id}\n")
            # Local path to encryption key
            f.write(f"{self.encryption_key_path}\n")
            # IV for this specific video
            f.write(f"{iv}\n")
        
        return key_info_path
    
    def get_video_info(self, input_path) -> Tuple[float, int, int]:
        """Get video duration and dimensions"""
        cmd = [
            'ffprobe', '-v', 'error',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=width,height,duration',
            '-of', 'json',
            str(input_path)
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        import json
        data = json.loads(result.stdout)
        stream = data['streams'][0]
        
        return (
            float(stream.get('duration', 0)),
            int(stream.get('width', 0)),
            int(stream.get('height', 0))
        )
    
    def generate_animated_thumbnail(self, input_path, output_dir, video_id, duration):
        """Generate animated WebP thumbnail"""
        thumbnail_path = output_dir / 'thumbnail.webp'
        preview_path = output_dir / 'preview.webp'
        
        # Calculate start time (skip first 10% of video)
        start_time = max(5, duration * 0.1)  # Start at 10% or 5 seconds
        
        # Generate 3-second animated thumbnail
        cmd_thumbnail = [
            'ffmpeg', '-i', str(input_path),
            '-ss', str(start_time),
            '-t', '3',  # 3-second duration
            '-vf', 'fps=10,scale=320:-1:flags=lanczos',
            '-loop', '0',  # Infinite loop
            '-compression_level', '6',
            '-quality', '75',
            '-f', 'webp',
            str(thumbnail_path)
        ]
        
        # Generate scene-based preview (best moments)
        cmd_preview = [
            'ffmpeg', '-i', str(input_path),
            '-vf', "select='gt(scene,0.4)',scale=480:-1:flags=lanczos,fps=5",
            '-frames:v', '20',  # Max 20 frames
            '-loop', '0',
            '-compression_level', '6',
            '-quality', '80',
            '-f', 'webp',
            str(preview_path)
        ]
        
        # Execute thumbnail generation
        subprocess.run(cmd_thumbnail, capture_output=True)
        subprocess.run(cmd_preview, capture_output=True)
        
        return thumbnail_path, preview_path
    
    def encrypt_file(self, file_path):
        """Encrypt WebP file with AES-128"""
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        import struct
        
        # Read encryption key
        with open(self.encryption_key_path, 'r') as f:
            key = bytes.fromhex(f.read().strip())
        
        # Generate IV for this file
        iv = os.urandom(16)
        
        # Read file
        with open(file_path, 'rb') as f:
            plaintext = f.read()
        
        # Pad data to 16-byte boundary
        pad_len = 16 - (len(plaintext) % 16)
        plaintext += bytes([pad_len]) * pad_len
        
        # Encrypt
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        
        # Write encrypted file (IV + ciphertext)
        encrypted_path = file_path.with_suffix('.webp.enc')
        with open(encrypted_path, 'wb') as f:
            f.write(iv + ciphertext)
        
        # Remove original
        file_path.unlink()
        
        return encrypted_path
    
    async def process_video(self, input_path, video_id):
        """Process video with HLS encryption and animated thumbnails"""
        output_dir = self.assets_dir / "videos" / video_id
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Get video information
        duration, width, height = self.get_video_info(input_path)
        
        # Generate unique IV for this video
        iv = self.generate_iv()
        
        # Create key info file
        key_info_path = self.create_key_info_file(video_id, iv)
        
        # Read encryption key
        with open(self.encryption_key_path, 'r') as f:
            encryption_key = f.read().strip()
        
        # Generate animated thumbnails first (in parallel)
        thumbnail_task = asyncio.create_task(
            asyncio.to_thread(
                self.generate_animated_thumbnail,
                input_path, output_dir, video_id, duration
            )
        )
        
        # FFmpeg command with HLS encryption
        cmd = [
            'ffmpeg', '-i', str(input_path),
            '-vf', f'scale=-1:720',
            '-c:v', 'libx264',
            '-preset', 'veryfast',
            '-crf', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-hls_time', '10',
            '-hls_list_size', '0',
            '-hls_segment_filename', str(output_dir / 'segment%03d.ts'),
            '-hls_key_info_file', str(key_info_path),
            '-hls_segment_type', 'mpegts',
            '-hls_flags', 'delete_segments+independent_segments',
            str(output_dir / 'stream.m3u8')
        ]
        
        # Execute FFmpeg for HLS
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise Exception(f"FFmpeg error: {result.stderr}")
        
        # Wait for thumbnail generation
        thumbnail_path, preview_path = await thumbnail_task
        
        # Encrypt thumbnails
        encrypted_thumbnail = self.encrypt_file(thumbnail_path)
        encrypted_preview = self.encrypt_file(preview_path)
        
        # Store metadata in database
        self.store_video_metadata(
            video_id, 
            iv, 
            duration,
            width,
            height,
            str(encrypted_thumbnail.relative_to(self.assets_dir)),
            str(encrypted_preview.relative_to(self.assets_dir))
        )
        
        # Clean up temporary key info file
        key_info_path.unlink()
        
        return output_dir

    def store_video_metadata(self, video_id, iv, duration, width, height, 
                           thumbnail_path, preview_path):
        """Store video encryption metadata in database"""
        # Database storage implementation
        # Store video_id, iv, encryption_key_id, dimensions, paths, etc.
        pass
```

### Encryption Key Management

#### Key Rotation Script
```python
#!/usr/bin/env python3
"""
Monthly encryption key rotation
"""

import os
import secrets
from datetime import datetime
from pathlib import Path

def rotate_encryption_key():
    """Generate new encryption key and archive old one"""
    private_dir = Path("/app/private")
    current_key_path = private_dir / "encryption.key"
    
    # Archive current key
    if current_key_path.exists():
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        archive_path = private_dir / f"encryption.key.{timestamp}"
        current_key_path.rename(archive_path)
    
    # Generate new key
    new_key = secrets.token_hex(16)
    with open(current_key_path, 'w') as f:
        f.write(new_key)
    
    # Update database with new key information
    # Implementation depends on your database schema
    
    print(f"Encryption key rotated successfully")
    print(f"New key: {new_key}")
    
if __name__ == "__main__":
    rotate_encryption_key()
```

## Security Implementation

### Encryption Service
- Master key stored in environment variables
- Individual encryption keys for each media file
- Key rotation every 30 days with versioning
- Secure key derivation using PBKDF2

### Session Security
- JWT tokens with short expiration (15 minutes)
- Refresh tokens stored in httpOnly cookies
- Device fingerprinting for session validation
- Automatic logout after 30 minutes of inactivity
- Rate limiting on authentication endpoints

### Media Access Security
- No direct URL access to media files
- All access through authenticated API endpoints
- Temporary signed URLs for HLS segments
- IP-based access restrictions
- Request throttling per user

## Error Handling

### Error Types
- `AUTH_001`: Invalid credentials
- `AUTH_002`: Token expired
- `AUTH_003`: Invalid token
- `AUTH_004`: Session expired
- `MEDIA_001`: File not found
- `MEDIA_002`: Processing failed
- `MEDIA_003`: Encryption error
- `MEDIA_004`: Invalid format
- `SYSTEM_001`: Database error
- `SYSTEM_002`: Storage error

### Error Response Format
```json
{
  "error": {
    "code": "AUTH_002",
    "message": "Token has expired",
    "details": "Please refresh your token",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

## Docker Data Persistence

### Volume Management
```yaml
# Named volumes for database persistence
volumes:
  postgres_data:    # PostgreSQL data
  redis_data:       # Redis persistence

# Bind mounts for media files
./imports:/app/imports      # Input media files
./assets:/app/assets        # Processed media files
./private:/app/private      # SSL certificates and keys
```

### Backup Strategy
```bash
# Backup database
docker-compose exec postgres pg_dump -U postgres media_streaming > backup.sql

# Backup media files
tar -czf media_backup_$(date +%Y%m%d).tar.gz assets/

# Backup Docker volumes
docker run --rm -v media_postgres_data:/data -v $(pwd):/backup \
  alpine tar czf /backup/postgres_backup_$(date +%Y%m%d).tar.gz -C /data .

# Restore database
docker-compose exec -T postgres psql -U postgres media_streaming < backup.sql

# Restore media files
tar -xzf media_backup_20240115.tar.gz
```

### Storage Considerations
- Ensure adequate disk space for media files
- Monitor Docker disk usage: `docker system df`
- Clean unused images: `docker system prune`
- Configure log rotation for containers

## Performance Considerations

### Caching Strategy
- Redis caching for session data
- CDN integration for static assets
- Browser caching headers for media
- Database query result caching

### Optimization Techniques
- Lazy loading for media gallery with animated thumbnails
- Progressive loading: static thumbnail → animated preview on hover
- Adaptive bitrate streaming for videos
- Connection pooling for database
- Worker pool for media processing
- WebP animation caching in browser
- Thumbnail generation in parallel with video processing
- Scene detection for intelligent preview generation

## Monitoring and Logging

### Metrics to Track
- User authentication attempts
- Media access patterns
- Processing queue length
- Error rates by type
- System resource usage
- API response times

### Log Formats
```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "level": "INFO",
  "service": "api",
  "event": "media_access",
  "user_id": "123e4567",
  "media_id": "456e7890",
  "duration_ms": 145,
  "status": "success"
}
```

## Docker Configuration

### docker-compose.yml
```yaml
version: '3.9'

services:
  postgres:
    image: postgres:15-alpine
    container_name: media-postgres
    platform: linux/amd64  # For Apple Silicon compatibility
    environment:
      POSTGRES_DB: ${DB_NAME:-media_streaming}
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secure_password}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    networks:
      - media-network
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: media-redis
    platform: linux/amd64  # For Apple Silicon compatibility
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password}
    volumes:
      - redis_data:/data
    networks:
      - media-network
    restart: unless-stopped

  media-processor:
    build:
      context: .
      dockerfile: docker/python/Dockerfile
      platforms:
        - linux/amd64
        - linux/arm64
    container_name: media-processor
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - PYTHONUNBUFFERED=1
    volumes:
      - ./imports:/app/imports
      - ./assets:/app/assets
      - ./private:/app/private
      - ./python:/app/python
    depends_on:
      - postgres
      - redis
    networks:
      - media-network
    restart: unless-stopped

  nextjs-app:
    build:
      context: .
      dockerfile: docker/nextjs/Dockerfile
      platforms:
        - linux/amd64
        - linux/arm64
    container_name: media-nextjs
    environment:
      - DB_HOST=postgres
      - REDIS_HOST=redis
      - NODE_ENV=production
    volumes:
      - ./assets:/app/assets:ro
      - ./private:/app/private:ro
    depends_on:
      - postgres
      - redis
    networks:
      - media-network
    restart: unless-stopped

  nginx:
    build:
      context: .
      dockerfile: docker/nginx/Dockerfile
    container_name: media-nginx
    platform: linux/amd64  # For Apple Silicon compatibility
    ports:
      - "1027:1027"
    volumes:
      - ./private/server.pem:/etc/nginx/ssl/server.pem:ro
      - ./assets:/app/assets:ro
    depends_on:
      - nextjs-app
    networks:
      - media-network
    restart: unless-stopped

networks:
  media-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
```

### docker/python/Dockerfile
```dockerfile
FROM python:3.12-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    ffmpeg \
    libpq-dev \
    gcc \
    openssl \
    libwebp-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy requirements and install Python dependencies
COPY python/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY python/ ./python/
COPY private/ ./private/

# Create necessary directories
RUN mkdir -p /app/imports /app/assets/images /app/assets/videos /app/temp

# Generate initial encryption key if not exists
RUN [ ! -f /app/private/encryption.key ] && openssl rand -hex 16 > /app/private/encryption.key || true

# Run the media processor
CMD ["python", "python/process_files.py"]
```

### python/requirements.txt
```txt
# Core dependencies
asyncpg==0.29.0
aiofiles==23.2.1
watchdog==4.0.0
pyyaml==6.0.1

# Image processing
Pillow==10.2.0
pillow-heif==0.15.0  # For HEIF/HEIC support

# Encryption
cryptography==42.0.2

# Database
psycopg2-binary==2.9.9
redis==5.0.1

# Async support
asyncio==3.4.3
aiohttp==3.9.3

# Utils
python-dotenv==1.0.0
click==8.1.7
colorama==0.4.6
```

### docker/nextjs/Dockerfile
```dockerfile
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY nextjs/package*.json ./
RUN npm ci

# Copy application code
COPY nextjs/ .

# Build the application
RUN npm run build

# Production stage
FROM node:20-alpine

WORKDIR /app

# Copy built application
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package*.json ./
COPY --from=builder /app/next.config.js ./

# Install production dependencies only
RUN npm ci --production

EXPOSE 3000

CMD ["npm", "start"]
```

### docker/nginx/Dockerfile
```dockerfile
FROM nginx:alpine

# Copy nginx configuration
COPY docker/nginx/nginx.conf /etc/nginx/nginx.conf

# Create SSL directory
RUN mkdir -p /etc/nginx/ssl

EXPOSE 1027

CMD ["nginx", "-g", "daemon off;"]
```

### docker/nginx/nginx.conf
```nginx
events {
    worker_connections 1024;
}

http {
    upstream nextjs {
        server nextjs-app:3000;
    }

    server {
        listen 1027 ssl;
        server_name _;

        ssl_certificate /etc/nginx/ssl/server.pem;
        ssl_certificate_key /etc/nginx/ssl/server.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;

        # Restrict access to allowed IPs
        allow 127.0.0.1;
        allow 192.168.1.0/24;
        allow 10.8.0.0/24;
        allow 172.16.0.0/12;  # Docker network
        deny all;

        location / {
            proxy_pass http://nextjs;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }

        # API routes
        location /api/ {
            proxy_pass http://nextjs;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## VPN Router Configuration

## VPN Router Configuration

### Router-Based OpenVPN Setup
The system requires a router with OpenVPN server capability configured with the following settings:

```bash
# Router OpenVPN Configuration (e.g., ASUS, DD-WRT, OpenWRT)
# Access router admin panel and configure OpenVPN server:

Port: 1194
Protocol: UDP
Device: TUN
VPN Subnet: 10.8.0.0
Netmask: 255.255.255.0
Client Access: Allow from WAN (Home Network Only)
Local Network Access: Yes
DNS: Router IP (e.g., 192.168.1.1)

# Advanced Settings:
Encryption: AES-128-CBC
Auth Digest: SHA256
TLS Control Channel: Enabled
Client-to-Client: Disabled
Username/Password Auth: Optional (Certificate-based recommended)
```

### Network Topology
```
[External Client] --> [Internet] --> [Home Router w/ OpenVPN]
                                              |
                                     +--------+--------+
                                     |                 |
                                [VPN Tunnel]    [Local Network]
                                (10.8.0.x)      (192.168.1.x)
                                     |                 |
                                     +--------+--------+
                                              |
                                    [Docker Host: localhost]
                                              |
                                    [Media Server: Port 1027]
                                              |
                              +---------------+---------------+
                              |               |               |
                         [PostgreSQL]    [Redis]      [Media Storage]
                          Container     Container      Volume Mount
```

### Client Access Configuration
```bash
# client.ovpn
client
dev tun
proto udp
remote [HOME_NETWORK_IP] 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert client.crt
key client.key
tls-auth ta.key 1
verb 3
```

### Client Access Guide

1. **Configure VPN Client**
   - Obtain OpenVPN configuration file from router admin
   - Install OpenVPN client on your device:
     - Windows: OpenVPN GUI
     - macOS: Tunnelblick or OpenVPN Connect
     - Linux: `sudo apt install openvpn`
     - Mobile: OpenVPN Connect app

2. **Import Router VPN Configuration**
   - Access router admin panel (e.g., 192.168.1.1)
   - Download client .ovpn file
   - Import into OpenVPN client
   - Enter credentials if required

3. **Connect to VPN**
   - Start OpenVPN connection
   - Verify VPN IP assignment (should be 10.8.0.x)
   - Test connectivity: `ping localhost`

4. **Access Media Server**
   - Open browser to `https://localhost:1027`
   - Accept self-signed certificate warning
   - Login with application credentials
   
5. **Alternative Access (Local Network)**
   - If on same local network (192.168.1.x)
   - Can access directly without VPN
   - Use same URL: `https://localhost:1027`

### Network Security Rules
```bash
# Router firewall configuration
# Allow VPN connections
iptables -A INPUT -p udp --dport 1194 -j ACCEPT

# Docker host firewall
# Allow port 1027 from VPN and local network
sudo ufw allow from 10.8.0.0/24 to any port 1027
sudo ufw allow from 192.168.1.0/24 to any port 1027
sudo ufw deny 1027  # Block all other access

# Docker automatic iptables rules
# Docker will automatically manage iptables for container networking
# No manual configuration needed for inter-container communication
```

## Deployment Guidelines

### Prerequisites
1. **Mac Mini Requirements**:
   - macOS 12.0+ (Monterey or later)
   - Docker Desktop for Mac 4.20+
   - Minimum 8GB RAM (16GB recommended)
   - 50GB+ free disk space
   - Static IP configuration (configurable)
2. Configure router with OpenVPN server
3. Install Docker Desktop for Mac
4. Enable virtualization framework in Docker settings
5. Allocate resources in Docker Desktop:
   - CPUs: 4+ cores
   - Memory: 6GB minimum
   - Disk: 50GB+
6. Open port 1027 on Mac firewall
7. Generate SSL certificates

### Installation Steps
```bash
# 1. Install Docker Desktop for Mac
# Download from https://www.docker.com/products/docker-desktop/
# For Apple Silicon: Docker Desktop for Mac with Apple silicon
# For Intel: Docker Desktop for Mac with Intel chip

# 2. Configure Docker Desktop
# - Open Docker Desktop preferences
# - Resources → Advanced: Set Memory to 6GB+, CPUs to 4+
# - Enable "Use virtualization framework" for better performance
# - Apply & Restart

# 3. Clone repository
git clone https://github.com/your-org/video-streaming-platform.git
cd video-streaming-platform

# 4. Create environment file
cp .env.example .env
# Edit .env with your settings

# 5. Generate SSL certificate
mkdir -p private
openssl req -x509 -newkey rsa:2048 -keyout private/server.pem \
  -out private/server.pem -days 365 -nodes \
  -subj "/CN=media-server" \
  -addext "subjectAltName = DNS:localhost,DNS:media-server,IP:127.0.0.1,IP:10.8.0.1"

# 6. Generate HLS encryption key
openssl rand -hex 16 > private/encryption.key

# 7. Set directory permissions (Mac specific)
chmod -R 755 imports assets private
# Note: Docker Desktop handles user mapping automatically

# 8. Configure Mac firewall
# System Preferences → Security & Privacy → Firewall → Firewall Options
# Add Docker Desktop and allow incoming connections

# 9. Build and start Docker containers
docker-compose build
docker-compose up -d

# 10. Check container status
docker-compose ps
docker-compose logs -f

# 11. Initialize database (first run only)
docker-compose exec postgres psql -U postgres -d media_streaming < database/schema.sql

# 12. Test connectivity
# From VPN-connected client:
curl -k https://localhost:1027/api/health

# 13. Access the application
# Open browser to: https://localhost:1027
```

### Mac-Specific Considerations

1. **Apple Silicon (M1/M2/M3) Macs**:
   - Use platform specification in docker-compose.yml
   - Some images may run under Rosetta 2 emulation
   - Performance is generally excellent with native arm64 images

2. **File System Performance**:
   - Use named volumes for databases (better performance)
   - Bind mounts for media files work well
   - Consider enabling VirtioFS in Docker Desktop settings

3. **Resource Allocation**:
   - Docker Desktop → Preferences → Resources
   - Allocate at least 6GB RAM (8GB+ recommended)
   - 4+ CPU cores for smooth media processing

4. **Network Configuration**:
   - Docker Desktop handles port forwarding automatically
   - Ensure Mac firewall allows port 1027
   - May need to disable AirPlay Receiver if port conflicts

5. **Storage Location**:
   - Docker volumes stored in: `~/Library/Containers/com.docker.docker/Data/vms/0/data`
   - Monitor disk usage in Docker Desktop dashboard

### Docker Management Commands
```bash
# View logs
docker-compose logs -f [service-name]

# Restart a service
docker-compose restart [service-name]

# Stop all services
docker-compose down

# Stop and remove volumes (WARNING: deletes data)
docker-compose down -v

# Update and rebuild
git pull
docker-compose build
docker-compose up -d

# Access container shell
docker-compose exec [service-name] sh

# Monitor resource usage
docker stats
```

### Environment Variables (.env file)
```bash
# Database
DB_HOST=postgres  # Docker service name
DB_PORT=5432
DB_NAME=media_streaming
DB_USER=postgres
DB_PASSWORD=secure_password

# Redis
REDIS_HOST=redis  # Docker service name
REDIS_PORT=6379
REDIS_PASSWORD=redis_password

# Security
JWT_ACCESS_SECRET=your_access_secret_here
JWT_REFRESH_SECRET=your_refresh_secret_here
MASTER_ENCRYPTION_KEY=your_master_key_here

# Application
APP_ENV=production
SERVER_HOST=0.0.0.0  # Bind to all interfaces in container
SERVER_PORT=1027
SSL_ENABLED=true

# Network Settings
HOST_IP=localhost
VPN_SUBNET=10.8.0.0/24
ALLOWED_NETWORKS=127.0.0.1,192.168.1.0/24,10.8.0.0/24,172.16.0.0/12
ENFORCE_VPN=true

# Media Processing
THUMBNAIL_WIDTH=320
THUMBNAIL_FPS=10
THUMBNAIL_DURATION=3
PREVIEW_WIDTH=480
PREVIEW_MAX_FRAMES=20
SCENE_THRESHOLD=0.4
PARALLEL_PROCESSING=true
MAX_WORKERS=4
```

## Development Environment

### docker-compose.dev.yml
```yaml
version: '3.9'

services:
  nextjs-app:
    build:
      context: .
      dockerfile: docker/nextjs/Dockerfile.dev
    volumes:
      - ./nextjs:/app
      - /app/node_modules
      - /app/.next
    environment:
      - NODE_ENV=development
    ports:
      - "3000:3000"  # Direct access for development
    command: npm run dev

  media-processor:
    volumes:
      - ./python:/app/python:ro
    environment:
      - DEBUG=1
      - PYTHONUNBUFFERED=1
```

### Local Development
```bash
# Use development compose file
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# Hot reload for Next.js
# Changes in ./nextjs will automatically reload

# Python debugging
docker-compose exec media-processor python -m pdb python/process_files.py
```

## Frontend Media Gallery with Animated Thumbnails

### React Component for Media Gallery
```typescript
// components/MediaGallery.tsx
import { useState, useEffect } from 'react';
import Image from 'next/image';
import VideoPlayer from './VideoPlayer';

interface MediaItem {
  id: string;
  name: string;
  type: 'image' | 'video';
  thumbnail_url: string;
  preview_url?: string;
  metadata: {
    width: number;
    height: number;
    duration?: number;
    size_bytes: number;
  };
}

export default function MediaGallery({ authToken }: { authToken: string }) {
  const [media, setMedia] = useState<MediaItem[]>([]);
  const [selectedMedia, setSelectedMedia] = useState<MediaItem | null>(null);
  const [hoveredId, setHoveredId] = useState<string | null>(null);

  useEffect(() => {
    fetchMedia();
  }, []);

  const fetchMedia = async () => {
    const response = await fetch('/api/media/library', {
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });
    const data = await response.json();
    setMedia(data.data);
  };

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatFileSize = (bytes: number) => {
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(1)} MB`;
  };

  return (
    <div className="container mx-auto p-4">
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
        {media.map((item) => (
          <div
            key={item.id}
            className="relative group cursor-pointer overflow-hidden rounded-lg shadow-lg transition-transform hover:scale-105"
            onClick={() => setSelectedMedia(item)}
            onMouseEnter={() => setHoveredId(item.id)}
            onMouseLeave={() => setHoveredId(null)}
          >
            {/* Animated Thumbnail */}
            <div className="relative aspect-video bg-gray-900">
              <img
                src={
                  hoveredId === item.id && item.preview_url
                    ? item.preview_url
                    : item.thumbnail_url
                }
                alt={item.name}
                className="w-full h-full object-cover"
                loading="lazy"
              />
              
              {/* Video Duration Overlay */}
              {item.type === 'video' && item.metadata.duration && (
                <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white text-xs px-2 py-1 rounded">
                  {formatDuration(item.metadata.duration)}
                </div>
              )}
              
              {/* Play Button Overlay for Videos */}
              {item.type === 'video' && (
                <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                  <div className="bg-black bg-opacity-50 rounded-full p-4">
                    <svg className="w-12 h-12 text-white" fill="currentColor" viewBox="0 0 20 20">
                      <path d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" />
                    </svg>
                  </div>
                </div>
              )}
            </div>
            
            {/* Media Info */}
            <div className="p-3 bg-white dark:bg-gray-800">
              <p className="text-sm font-medium truncate">{item.name}</p>
              <div className="flex justify-between items-center mt-1">
                <span className="text-xs text-gray-500">
                  {item.metadata.width}x{item.metadata.height}
                </span>
                <span className="text-xs text-gray-500">
                  {formatFileSize(item.metadata.size_bytes)}
                </span>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Media Viewer Modal */}
      {selectedMedia && (
        <div className="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4">
          <div className="relative max-w-7xl w-full">
            {/* Close Button */}
            <button
              onClick={() => setSelectedMedia(null)}
              className="absolute -top-12 right-0 text-white hover:text-gray-300"
            >
              <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>

            {/* Media Display */}
            {selectedMedia.type === 'video' ? (
              <VideoPlayer videoId={selectedMedia.id} authToken={authToken} />
            ) : (
              <img
                src={`/api/media/stream/${selectedMedia.id}`}
                alt={selectedMedia.name}
                className="w-full h-auto max-h-[80vh] object-contain"
              />
            )}

            {/* Media Info */}
            <div className="mt-4 text-white">
              <h3 className="text-xl font-semibold">{selectedMedia.name}</h3>
              <p className="text-sm text-gray-300 mt-1">
                {selectedMedia.metadata.width}x{selectedMedia.metadata.height} • 
                {formatFileSize(selectedMedia.metadata.size_bytes)}
                {selectedMedia.metadata.duration && ` • ${formatDuration(selectedMedia.metadata.duration)}`}
              </p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
```

### CSS for Smooth Animation Transitions
```css
/* styles/gallery.css */
.media-thumbnail {
  transition: opacity 0.3s ease-in-out;
}

/* Preload animation on hover */
.media-item:hover .thumbnail-static {
  opacity: 0;
}

.media-item:hover .thumbnail-animated {
  opacity: 1;
}

/* WebP animation performance optimization */
.webp-animation {
  will-change: contents;
  backface-visibility: hidden;
  transform: translateZ(0);
}
```

## Testing Strategy

### Unit Tests
- Authentication service tests
- Encryption/decryption tests for media and thumbnails
- Animated WebP generation tests
- Media processing tests
- API endpoint tests
- Thumbnail serving tests

### Integration Tests
- End-to-end authentication flow
- Media upload and processing with thumbnail generation
- Animated thumbnail display in gallery
- Session management
- Error handling
- HLS playback with encryption

### Performance Tests
- Thumbnail generation speed
- Parallel processing efficiency
- Gallery loading with animated previews
- Memory usage during WebP encoding

### Security Tests
- Penetration testing
- SQL injection prevention
- XSS prevention
- CSRF protection
- Encrypted thumbnail access control

## Maintenance Procedures

### Daily Tasks
- Monitor error logs
- Check processing queue
- Verify backup completion

### Weekly Tasks
- Review access logs
- Update security patches
- Clean temporary files

### Monthly Tasks
- Rotate encryption keys
- Archive old logs
- Performance analysis
- Security audit

## Troubleshooting Guide

### Common Issues

1. **VPN Connection Issues**
   - Check router VPN service status
   - Verify UDP port 1194 is open on router
   - Confirm client certificate validity
   - Check router logs for connection attempts
   - Test connectivity: `ping localhost`

2. **Cannot Access Application**
   - Ensure VPN is connected (if accessing remotely)
   - Check Docker containers: `docker-compose ps`
   - Verify nginx is running: `docker logs media-nginx`
   - Try local access: `https://localhost:1027`
   - Check firewall allows port 1027

3. **Docker Container Issues (Mac Specific)**
   - Check Docker Desktop is running
   - Verify resource allocation in Docker Desktop settings
   - Ensure virtualization framework is enabled
   - Check container logs: `docker-compose logs [service]`
   - For Apple Silicon: Verify platform compatibility
   - Restart Docker Desktop if containers are unresponsive

4. **HLS Encryption Issues**
   - Verify encryption key exists: `docker exec media-processor cat /app/private/encryption.key`
   - Check key_info.txt format is correct (3 lines)
   - Ensure FFmpeg has access to key file
   - Verify IV is properly generated (32 hex characters)
   - Test key endpoint: `curl -k -H "Authorization: Bearer TOKEN" https://localhost:1027/api/media/keys/VIDEO_ID`
   - Check playlist contains EXT-X-KEY tag

5. **Video Playback Issues**
   - Ensure HLS.js or native player supports AES-128
   - Verify authentication token is passed to key requests
   - Check browser console for CORS errors
   - Confirm all .ts segments were encrypted
   - Test with unencrypted video to isolate encryption issues

6. **Animated Thumbnail Issues**
   - Verify FFmpeg has WebP support: `docker exec media-processor ffmpeg -formats | grep webp`
   - Check if libwebp is installed in container
   - Ensure sufficient memory for parallel processing
   - Test thumbnail generation manually:
     ```bash
     docker exec media-processor ffmpeg -i /app/imports/test.mp4 \
       -vf "fps=10,scale=320:-1" -t 3 -loop 0 -f webp test.webp
     ```
   - Verify thumbnail encryption/decryption
   - Check browser WebP support
   - Monitor CPU usage during thumbnail generation

7. **Media Processing Fails**
   - Check FFmpeg installation
   - Verify file permissions
   - Review error logs
   - Check disk space

2. **Authentication Issues**
   - Verify JWT secrets
   - Check Redis connection
   - Review token expiration
   - Validate CORS settings

3. **Streaming Problems**
   - Check encryption keys
   - Verify HLS segments
   - Review network connectivity
   - Check SSL certificates

4. **Performance Issues**
   - Monitor database queries
   - Check Redis performance
   - Review worker pool size
   - Analyze API response times